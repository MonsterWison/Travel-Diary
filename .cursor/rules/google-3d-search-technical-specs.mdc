# Google Search ä¸‰ç¶­æœå°‹æŠ€è¡“è¦æ ¼æ›¸

## æŠ€è¡“æ¶æ§‹æ¦‚è¦½

### æ ¸å¿ƒé¡åˆ¥çµæ§‹
```swift
class AttractionsManagementViewModel: ObservableObject {
    // ä¸‰ç¶­æœå°‹çš„æ ¸å¿ƒå¯¦ç¾
    func findBestMatchWithAdvanced3DSearch() -> AttractionCache?
    
    // èªæ„ç¶­åº¦è™•ç†
    func calculateSemanticSimilarity(_ query: String, _ candidate: String) -> Double
    func expandQueryWithSynonyms(_ query: String) -> Set<String>
    func extractMainWords(_ name: String) -> Set<String>
    
    // åœ°ç†ç¶­åº¦è™•ç†
    func calculateGeographicSimilarity(_ compareModel: CompareModel, _ candidate: AttractionCache) -> Double
    func calculateDistance(lat1: Double, lon1: Double, lat2: Double, lon2: Double) -> Double
    
    // é¡å‹ç¶­åº¦è™•ç†
    func calculateTypeSimilarity(_ compareModel: CompareModel, _ candidate: AttractionCache) -> Double
    
    // å‹•æ…‹èª¿æ•´ç³»çµ±
    func calculateDynamicWeights(_ query: String, _ candidate: String) -> (semantic: Double, geographic: Double, type: Double)
    func calculateConfidenceThreshold(_ query: String) -> Double
}
```

## èªæ„ç¶­åº¦å¯¦æ–½ç´°ç¯€

### åŒç¾©è©æ“´å±•ç³»çµ±
```swift
private func expandQueryWithSynonyms(_ query: String) -> Set<String> {
    let synonyms: [String: [String]] = [
        "temple": ["shrine", "monastery", "pagoda", "sanctuary", "cathedral", "church"],
        "museum": ["gallery", "exhibition", "collection", "center", "centre"],
        "beach": ["shore", "coast", "bay", "waterfront", "seaside"],
        "square": ["plaza", "piazza", "place", "courtyard", "park"],
        "station": ["terminal", "depot", "stop", "hub"],
        "market": ["bazaar", "marketplace", "mart", "fair"],
        // ... æ›´å¤šåŒç¾©è©
    ]
    
    var expanded = Set([query.lowercased()])
    let words = query.lowercased().components(separatedBy: CharacterSet(charactersIn: " -_,.()[]{}'\"/\\"))
    
    for word in words {
        if let syns = synonyms[word] {
            expanded.formUnion(syns)
        }
    }
    
    return expanded
}
```

### ä¸»é«”è©æå–ç®—æ³•
```swift
private func extractMainWords(_ name: String) -> Set<String> {
    let ignoreWords = [
        // è‹±æ–‡åœç”¨è©
        "congregation", "temple", "church", "mosque", "cathedral", "synagogue",
        "school", "museum", "gallery", "park", "beach", "pier", "square", "station",
        "center", "centre", "hall", "library", "shrine", "hotel", "restaurant",
        "of", "the", "at", "in", "on", "and", "de", "la", "le", "el",
        "saint", "st", "san", "santa", "new", "old", "big", "small",
        
        // ä¸­æ–‡åœç”¨è©
        "çš„", "äº†", "åœ¨", "æ˜¯", "æˆ‘", "æœ‰", "å’Œ", "å°±", "ä¸", "äºº", "éƒ½",
        "å¯ºå»Ÿ", "åšç‰©é¤¨", "å…¬åœ’", "æµ·ç˜", "å»£å ´", "è»Šç«™", "ä¸­å¿ƒ", "åœ–æ›¸é¤¨",
        "é…’åº—", "é¤å»³", "å®®æ®¿", "å¡”", "æ©‹", "èŠ±åœ’", "å¸‚å ´", "å¤§è¡—"
    ]
    
    return Set(
        name.lowercased()
            .components(separatedBy: CharacterSet(charactersIn: " -_,.()[]{}'\"/\\"))
            .filter { !$0.isEmpty && $0.count > 2 && !ignoreWords.contains($0) }
    )
}
```

### èªæ„ç›¸ä¼¼åº¦è¨ˆç®—
```swift
private func calculateSemanticSimilarity(_ query: String, _ candidate: String) -> Double {
    let queryExpanded = expandQueryWithSynonyms(query)
    let candidateExpanded = expandQueryWithSynonyms(candidate)
    
    let queryWords = extractMainWords(query)
    let candidateWords = extractMainWords(candidate)
    
    // 1. ä¸»è©äº¤é›†åŒ¹é…ï¼ˆâ‰¥2 å€‹äº¤é›†ç›´æ¥é€šéï¼‰
    let intersection = queryWords.intersection(candidateWords)
    if intersection.count >= 2 {
        return 0.95 // é«˜åº¦ç›¸ä¼¼
    }
    
    // 2. åŒç¾©è©æ“´å±•åŒ¹é…
    let synonymIntersection = queryExpanded.intersection(candidateExpanded)
    let synonymScore = Double(synonymIntersection.count) / Double(queryExpanded.union(candidateExpanded).count)
    
    // 3. Jaccard ç›¸ä¼¼åº¦
    let jaccard = Double(intersection.count) / Double(queryWords.union(candidateWords).count)
    
    // 4. æ”¹é€²çš„ Levenshtein è·é›¢
    let levDistance = levenshteinDistance(query.lowercased(), candidate.lowercased())
    let maxLen = max(query.count, candidate.count)
    let levScore = maxLen > 0 ? 1.0 - Double(levDistance) / Double(maxLen) : 0.0
    
    // 5. å­—ç¬¦ N-gram ç›¸ä¼¼åº¦
    let ngramScore = calculateNGramSimilarity(query, candidate)
    
    // 6. å¤šèªè¨€åŒ¹é…
    let multilingualScore = calculateMultilingualSimilarity(query, candidate)
    
    // ç¶œåˆèªæ„åˆ†æ•¸
    return max(
        synonymScore * 0.3 + 
        jaccard * 0.25 + 
        levScore * 0.2 + 
        ngramScore * 0.15 + 
        multilingualScore * 0.1,
        intersection.count > 0 ? 0.6 : 0.0
    )
}
```

## åœ°ç†ç¶­åº¦å¯¦æ–½ç´°ç¯€

### éç·šæ€§è·é›¢è©•åˆ†
```swift
private func calculateGeographicSimilarity(_ compareModel: CompareModel, _ candidate: AttractionCache) -> Double {
    let distance = calculateDistance(
        lat1: compareModel.latitude, lon1: compareModel.longitude,
        lat2: candidate.latitude, lon2: candidate.longitude
    )
    
    // éç·šæ€§è·é›¢è©•åˆ†
    let baseScore: Double
    if distance < 0.1 {
        baseScore = 1.0 // 100m å…§å®Œç¾åŒ¹é…
    } else if distance < 0.5 {
        baseScore = 0.95 // 500m å…§é«˜åº¦åŒ¹é…
    } else if distance < 1.0 {
        baseScore = 0.85 // 1km å…§è‰¯å¥½åŒ¹é…
    } else if distance < 2.0 {
        baseScore = 0.7 // 2km å…§å¯æ¥å—
    } else if distance < 5.0 {
        baseScore = 0.5 // 5km å…§é‚Šç·£åŒ¹é…
    } else if distance < 10.0 {
        baseScore = 0.3 // 10km å…§ä½åŒ¹é…
    } else {
        baseScore = max(0.0, 0.2 - distance / 100.0) // é è·é›¢è¡°æ¸›
    }
    
    // æ™¯é»é¡å‹è·é›¢å®¹å¿åº¦èª¿æ•´
    let typeDistanceTolerance = getDistanceToleranceForType(candidate)
    
    return min(1.0, baseScore + typeDistanceTolerance)
}
```

### Haversine è·é›¢è¨ˆç®—
```swift
private func calculateDistance(lat1: Double, lon1: Double, lat2: Double, lon2: Double) -> Double {
    let R = 6371.0 // åœ°çƒåŠå¾‘ï¼ˆå…¬é‡Œï¼‰
    let dLat = (lat2 - lat1) * .pi / 180
    let dLon = (lon2 - lon1) * .pi / 180
    let a = sin(dLat/2) * sin(dLat/2) + cos(lat1 * .pi / 180) * cos(lat2 * .pi / 180) * sin(dLon/2) * sin(dLon/2)
    let c = 2 * atan2(sqrt(a), sqrt(1-a))
    return R * c
}
```

## é¡å‹ç¶­åº¦å¯¦æ–½ç´°ç¯€

### æ™¯é»åˆ†é¡ç³»çµ±
```swift
private func calculateTypeSimilarity(_ compareModel: CompareModel, _ candidate: AttractionCache) -> Double {
    let categories: [String: [String]] = [
        "religious": ["temple", "church", "mosque", "synagogue", "cathedral", "shrine", "monastery"],
        "cultural": ["museum", "gallery", "theater", "opera", "concert", "cultural", "art"],
        "recreational": ["park", "garden", "zoo", "aquarium", "amusement", "playground"],
        "natural": ["beach", "lake", "mountain", "forest", "river", "waterfall", "cave"],
        "transportation": ["station", "airport", "port", "terminal", "depot", "hub"],
        "commercial": ["market", "mall", "shopping", "store", "restaurant", "hotel"],
        "historical": ["castle", "palace", "fort", "monument", "memorial", "historic"],
        "educational": ["university", "college", "school", "library", "institute"],
        "medical": ["hospital", "clinic", "medical", "health", "pharmacy"],
        "government": ["city hall", "courthouse", "embassy", "consulate", "government"],
        "sports": ["stadium", "arena", "gym", "sports", "field", "court"],
        "entertainment": ["cinema", "theater", "club", "bar", "entertainment"]
    ]
    
    // åˆ†é¡åŒ¹é…é‚è¼¯
    let queryName = compareModel.names["en"]?.lowercased() ?? ""
    let candidateName = candidate.names["en"]?.lowercased() ?? ""
    
    var queryCategory = "unknown"
    var candidateCategory = "unknown"
    
    // æ‰¾å‡ºæŸ¥è©¢å’Œå€™é¸çš„é¡å‹
    for (category, keywords) in categories {
        if keywords.contains(where: { queryName.contains($0) }) {
            queryCategory = category
        }
        if keywords.contains(where: { candidateName.contains($0) }) {
            candidateCategory = category
        }
    }
    
    // è¨ˆç®—é¡å‹ç›¸ä¼¼åº¦
    if queryCategory == candidateCategory && queryCategory != "unknown" {
        return 1.0 // å®Œå…¨åŒ¹é…
    }
    
    // ç›¸é—œé¡å‹çš„éƒ¨åˆ†åŒ¹é…
    let relatedCategories: [String: [String]] = [
        "religious": ["historical", "cultural"],
        "cultural": ["historical", "educational"],
        "recreational": ["natural", "entertainment"],
        "natural": ["recreational"],
        "historical": ["cultural", "religious"],
        "educational": ["cultural"]
    ]
    
    if let related = relatedCategories[queryCategory], related.contains(candidateCategory) {
        return 0.6 // ç›¸é—œé¡å‹
    }
    
    return 0.0 // ç„¡åŒ¹é…
}
```

## å‹•æ…‹èª¿æ•´ç³»çµ±

### æ¬Šé‡å‹•æ…‹è¨ˆç®—
```swift
private func calculateDynamicWeights(_ query: String, _ candidate: String) -> (semantic: Double, geographic: Double, type: Double) {
    let queryLower = query.lowercased()
    
    // æ ¹æ“šæŸ¥è©¢ç‰¹å¾µèª¿æ•´æ¬Šé‡
    if queryLower.contains("near") || queryLower.contains("nearby") {
        return (0.3, 0.6, 0.1) // åœ°ç†æ¬Šé‡å¢åŠ 
    } else if queryLower.contains("type") || queryLower.contains("kind") {
        return (0.4, 0.3, 0.3) // é¡å‹æ¬Šé‡å¢åŠ 
    } else if queryLower.count > 30 {
        return (0.6, 0.3, 0.1) // é•·æŸ¥è©¢å¢åŠ èªæ„æ¬Šé‡
    }
    
    return (0.5, 0.4, 0.1) // é è¨­æ¬Šé‡
}
```

### ç½®ä¿¡åº¦é–€æª»è¨ˆç®—
```swift
private func calculateConfidenceThreshold(_ query: String) -> Double {
    let queryLower = query.lowercased()
    
    // æ ¹æ“šæŸ¥è©¢ç‰¹å¾µèª¿æ•´é–€æª»
    if queryLower.contains("exact") || queryLower.contains("specific") {
        return 0.85 // ç²¾ç¢ºæŸ¥è©¢éœ€è¦æ›´é«˜ç½®ä¿¡åº¦
    } else if queryLower.count < 10 {
        return 0.6 // çŸ­æŸ¥è©¢é™ä½é–€æª»
    }
    
    return 0.7 // é è¨­é–€æª»
}
```

## æ€§èƒ½å„ªåŒ–æŒ‡å—

### ç·©å­˜ç­–ç•¥
```swift
// åŒç¾©è©æ“´å±•çµæœç·©å­˜
private var synonymCache: [String: Set<String>] = [:]

// è·é›¢è¨ˆç®—çµæœç·©å­˜
private var distanceCache: [String: Double] = [:]

// ä¸»è©æå–çµæœç·©å­˜
private var mainWordsCache: [String: Set<String>] = [:]
```

### æ‰¹æ¬¡è™•ç†
```swift
// æ‰¹æ¬¡è™•ç†å€™é¸æ™¯é»ï¼Œæé«˜æ•ˆç‡
func processCandidatesInBatches(_ candidates: [AttractionCache], batchSize: Int = 100) -> AttractionCache? {
    var bestMatch: AttractionCache?
    var bestScore: Double = 0.0
    
    for batch in candidates.chunked(into: batchSize) {
        let batchResult = processBatch(batch)
        if let result = batchResult, result.score > bestScore {
            bestMatch = result.candidate
            bestScore = result.score
        }
    }
    
    return bestMatch
}
```

## èª¿è©¦å’Œç›£æ§

### è©³ç´°æ—¥èªŒè¼¸å‡º
```swift
private func printScoringResults(_ results: [(AttractionCache, Double, String)], bestScore: Double) {
    print("=== ä¸‰ç¶­æœå°‹è©•åˆ†çµæœ ===")
    let sortedResults = results.sorted { $0.1 > $1.1 }
    for (index, (candidate, score, breakdown)) in sortedResults.prefix(5).enumerated() {
        let marker = score == bestScore ? "ğŸ†" : "ğŸ“"
        print("\(marker) \(index + 1). \(candidate.names["en"] ?? "Unknown") - \(breakdown)")
    }
    print("========================")
}
```

### æ€§èƒ½ç›£æ§
```swift
// åŒ¹é…æ™‚é–“ç›£æ§
let startTime = CFAbsoluteTimeGetCurrent()
let result = findBestMatchWithAdvanced3DSearch()
let timeElapsed = CFAbsoluteTimeGetCurrent() - startTime
print("åŒ¹é…è€—æ™‚: \(timeElapsed * 1000)ms")

// è¨˜æ†¶é«”ä½¿ç”¨ç›£æ§
let memoryUsage = getMemoryUsage()
print("è¨˜æ†¶é«”ä½¿ç”¨: \(memoryUsage)MB")
```

## æ¸¬è©¦æ¡†æ¶

### å–®å…ƒæ¸¬è©¦
```swift
func testSemanticSimilarity() {
    let viewModel = AttractionsManagementViewModel()
    
    // æ¸¬è©¦åŒç¾©è©åŒ¹é…
    let score1 = viewModel.calculateSemanticSimilarity("Buddhist Temple", "Man Mo Temple")
    XCTAssertGreaterThan(score1, 0.7)
    
    // æ¸¬è©¦ç¸®å¯«åŒ¹é…
    let score2 = viewModel.calculateSemanticSimilarity("Congregation Sherith Israel", "Shearith Israel")
    XCTAssertGreaterThan(score2, 0.8)
    
    // æ¸¬è©¦ä¸­æ–‡åŒ¹é…
    let score3 = viewModel.calculateSemanticSimilarity("éŠ€ç·šç£æ³³ç˜", "éŠ€ç·šç£")
    XCTAssertGreaterThan(score3, 0.8)
}
```

### é›†æˆæ¸¬è©¦
```swift
func testComplete3DSearch() {
    let viewModel = AttractionsManagementViewModel()
    
    // è¨­å®šæ¸¬è©¦æ•¸æ“š
    let compareModel = CompareModel(
        names: ["en": "Congregation Sherith Israel"],
        address: "San Francisco, CA",
        latitude: 37.7749,
        longitude: -122.4194
    )
    
    let candidates = [
        AttractionCache(
            names: ["en": "Shearith Israel"],
            addresses: ["en": "San Francisco, CA"],
            latitude: 37.7750,
            longitude: -122.4195,
            descriptions: ["en": "Historic synagogue"],
            source: "test"
        )
    ]
    
    viewModel.setCompareModel(compareModel)
    viewModel.setAttractionCandidates(candidates)
    
    XCTAssertNotNil(viewModel.bestMatch)
    XCTAssertEqual(viewModel.bestMatch?.names["en"], "Shearith Israel")
}
```

---

**æŠ€è¡“è¦æ±‚**ï¼š
- Swift 5.0+
- iOS 18.0+
- Xcode 16.0+
- æ”¯æ´ SwiftUI å’Œ Combine

**æ€§èƒ½åŸºæº–**ï¼š
- åŒ¹é…æ™‚é–“ < 100msï¼ˆ1000 å€‹å€™é¸æ™¯é»ï¼‰
- è¨˜æ†¶é«”ä½¿ç”¨ < 50MB
- æº–ç¢ºåº¦ > 88%
description:
globs:
alwaysApply: false
---
